# Вопросы:
## Что такое поток?
Поток — это сущность внутри процесса, для которой можно запланировать выполнение. Все потоки процесса совместно используют свои виртуальные адресные пространства и системные ресурсы. Кроме того, каждый поток поддерживает обработчики исключений, приоритет планирования, локальное хранилище потока, уникальный идентификатор потока и набор структур, которые система будет использовать для сохранения контекста потока, пока он не будет запланирован. Контекст потока включает набор регистров компьютера, стек ядра, блок среды потока и пользовательский стек в адресном пространстве процесса потока. Потоки также могут иметь собственный контекст безопасности, который можно использовать для олицетворения клиентов.

## Почему InterLockedIncrement
Надо использовать неделимые операции:
InterLockedIncrement, InterLockedDecrement
Позволяют сделать инкремент как неделимую операцию -> гарантия, что операция будет выполнена. Атомарная операция — операция, которая либо выполняется целиком, либо не выполняется вовсе; операция, которая не может быть частично выполнена и частично не выполнена.

## Опишите задачу читатели писатели:
Для этой задачи характерно наличие двух типов процессов: процессов «читателей», которые могут только читать данные, и процессов «писателей», которые могут только изменять данные.  Читатели могут работать параллельно, поскольку они друг другу не мешают (данные не изменяют), а писатели могут работать только в режиме монопольного доступа: только один писатель может получить доступ к разделяемой переменной, причем, когда работает писатель, то другие писатели и читатели не могут получить доступ к этой переменной. Рассмотрим монитор Хоара «Читатели-писатели», для которого характерно наличие четырех процедур: start_read(), stop_read(), start_write(), stop_write().

## Как потоки взаимодействуют между собой? Что они разделяют
Event (событие) позволяет известить один или несколько ожидающих потоков о наступлении какого-либо события.  События используются потоками для сигнализации, что другой поток может выполнить какую-то работу.

SetEvent - устанавливает объект в сигнальное состояние
ResetEvent - сбрасывает объект, устанавлия в несигнальное состояние 
PulseEvent - устанавливает объект в сигнальное состояние, дает отработать всем функциям ожидания, ожидающим этот объект, а затем снова сбрасывает его.

С помощью событий, этот механизм исользуется потоками для сигнализации, что другой поток может выполнить какую-то работу. 

Новый поток выполняется в контексте того же процесса, что и родительский поток. Поэтому он получает доступ ко всем описателям объектов ядра, всей памяти и стекам всех потоков в процессе. За счет этого потоки в рамках одного процесса могут легко взаимодействовать друг с другом. 

Другими словами поток своего адресного пространства не имеет, а выполняется в адресном пространстве процесса параллельно с другими потоками, если они созданы, и может разделять с ними глобальные переменные. Владельцем ресурсов является процесс.

## Типы событий в виндах. Для какого типа процессов вы использовали событие с автосбросом, а для какого с ручным сбросом
События используются потоками для сигнализации, что другой поток может выполнить какую-то работу. 
Типы:
Со сбросом вручную - будучи установленным в сигнальное состояние, остается в нем до тех пор, пока не будет переключен явным вызовом функции ResetEvent.
С автосбросом - автоматически переключается в несигнальное состояние операционной системой, когда один из ожидающих его потоков завершается.

В программе используются события с автосбросом для can_write (писателей) и сбросом вручную для can_read (читателей).

## почему
В программе используются события с автосбросом для can_write (писателей) и сбросом вручную для can_read (читателей) потому, что писатели должны обладать монопольным доступом к данным, что достигается с помощью автосброса - после вызова главным (первичным) потоком функции SetEvent система возобновит выполнение только одного из вторичных потоков. Какого именно — заранее сказать нельзя. Остальные два потоки продолжат ожидание. Поток, вновь ставший планируемым (выйдя из блокировки), получает монопольный доступ к блоку памяти, где хранятся данные, а читатели могут работать параллельно, так как процедура start_read завершается выдачей сигнала signal(can_read), чтобы следующий читатель в очереди читателей смог начать чтение. Каждый следующий читатель, начав чтение выдает signal(can_read), активизирует следующего читателя в очереди читателей. В результате возникает цепная реакция активизации читателей и она будет идти до тех пор, пока не активизируются все ожидающие читатели. «Цепная реакция» читателей является отличительной особенностью данного решения, которое эффективно «запускает» параллельное выполнение читателей. Процедура stop_read уменьшает количество активных читателей: читателей, начавших чтение. После ее многократного выполнения количество читателей может стать равным нулю. Если число читателей равно нулю, выполняется signal(can_write), активизирующий писателя из очереди писателей.

## Что такое потерянное обновление
Потерянное обновление это ситуация, когда несколько процессов изменяют одни и те же данные и изменения одних могут немедленно перекрываться изменениями других.

## Почему оно происходит
Появляются при параллельном доступе к данным. По алгоритму читатель не может начать читать, если есть работающий писатель и ждущие писатели. И поэтому писатели переписывают информацию до того, как читатель успевает её прочитать.

## Что такое режим монопольного доступа
Режим монопольного доступа: только один писатель может получить доступ к разделяемой переменной, причем, когда работает писатель, то другие писатели и читатели не могут получить доступ к этой переменной. 

## Вы в функции start_read использовали мьютекс. Что можно сказать о последовательности операторов, которые находятся между захватом и освобождением мьютекса?
Объекты ядра «мьютексы» гарантируют потокам взаимоисключающий доступ к единственному ресурсу. Они содержат счетчик числа пользователей, счетчик рекурсии и переменную, в которой запоминается идентификатор потока. Мьютексы ведут себя точно так же, как и критические секции. Однако, если последние являются объектами пользовательского режима, то мьютексы это — объекты ядра. Кроме того, единственный объект-мьютекс позволяет синхронизировать доступ к ресурсу нескольких потоков, принадлежащих разным процессам. Можно задать максимальное время ожидания доступа к ресурсу.

Данные операторы, находящиеся между захватом и освобождением находятся в критической секции.

# Пояснения
CreateMutex(NULL, FALSE, NULL)
NULL - не задаём права/защиту - по умолчанию
FALSE - свободен с самого начала, иначе будет захвачен вызвавшим потоком
NULL - имя, при NULL без имени

CreateEvent(NULL, FALSE, FALSE, NULL)
NULL - адрес структуры параметров защиты, без них - по умолчанию
FALSE - задаёт переключаемый вручную (TRUE) или автоматический (FALSE)
FALSE - начальное состояние, TRUE - в сигнальном
NULL - имя, если NULL, то его нет

CreateThread(NULL, 0, reader_run, (LPVOID)i, 0, NULL)
NULL - указатель на адрес структуры с правами
0 - размер стека в байтах, 0 - задать по умолчанию
reader_run - процедура, с которой начинается выполнение потока
(LPVOID)i - указатель на аргумент
0 - флаги
NULL - указатель на место записи ThreadId созданного потока

WaitForMultipleObjects(WRITERS_COUNT, writers_threads, TRUE, INFINITE)
WRITERS_COUNT - количество объектов
writers_threads - массив дескрипторов
TRUE - ожидание перехода в сигнальное состояние всех объектов, иначе - любого из указанных
INFINITE - без времени ожидания (ждёт бесконечно)