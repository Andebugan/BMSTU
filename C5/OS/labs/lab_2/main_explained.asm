.386P ;разрешаем использование набора команд 80386 для реального и защищённого режима

; Линейный адрес - не выражен в виде сегмент:смещение, выражен в виде номера байта в адресном пространстве.
; В нашем случае работает также как и физический адрес но в общем случае это не так.
; В адресном пространстве, если включена страничная адресация, то линейный адрес может не совпадать с физическим, если
; выключена, то совпадает.

; База сегмента - опеределяет начальный линейный адрес сегмента в адресном пространстве

; В защищённом режиме сегмент может распологаться в любом месте доступного адресного пространства (4Гбайт).
; (base_L) 16 + (base_M) 8 + (base_H) 8 = 32 - 2^30 - 4 Гбайта

; ATTR_2 - старшине 4 бита номера последнего байта сегмента. lim (16) + ATTR_2 (4) = 20
; Размер сегмента ограничен 2^20
; Старший бит attr_2 указывает на единицы, в которых задаётся граница, если 0, то в байтах (max - 1kb), если 1,
; то в блоках по 4кб, тогда ограничение будет 4 Гбайта

; линейный адрес = базовый адрес + смещение

; структура для описания дескрипторов сегментов
SEGDESCR STRUC ; начало объявления структуры
    LIMIT   DW 0 ; граница, биты 0 - 15
    BASE_L  DW 0 ; база, биты 0 - 15 - младшее слово
    BASE_M  DB 0 ; база, биты 16 - 23 - среднее слово
    ATTR_1  DB 0 ; байт атрибутов 1
    ATTR_2  DB 0 ; граница, биты 24 - 31 и атрибуты 2
    BASE_H  DB 0 ; база, биты 24 - 31 - старшее слово
SEGDESCR ENDS ; конец объявления структуры

; структура для описания дескрипторов прерывания (IDT), данный дескриптор называется шлюзом
INTDESCR STRUC ; начало объявления структуры
    OFFS_L  DW 0 ; смещение
    SEL     DW 0 ; селектор
    ; селектор - номер дескриптора из таблицы дескрипторов (ID + table indicator + RPL - requested privelege level)
    ; СЕЛЕКТОР:
    ; XXXXXXXX XXXXX YZZ
    ; XXXXXXXX XXXXX - номер дескриптора сегмента в GDT
    ; Y - TI (table indicator)
    ; ZZ - RPL - requested privilege level

    CNTR    DB 0 ; счётчик - используется для хранения числа параметров, копируемых
    ; из одного стека в другой (В случаях перехода с одного режима на другой (с одного стека на другой))
    ATTR    DB 0 ; байт атрибутов (такой же как и в descr атрибут attr_1)
    OFFS_H  DW 0 ; смещение
INTDESCR ENDS ; конец объявления структуры

; описываем разрядный сегмент стэка
STACK32 SEGMENT  PARA STACK 'STACK'
    ; создаём стек и заполняем его нулями
    STACK_START DB  100H DUP(?)
    ; размер стека - конец - начало
    STACK_SIZE=$-STACK_START
STACK32 ENDS

; описывает разрядный сегмент данных
; селекторы равны 8, 16, 32.. => значит первые 3 бита == 0 и TI ==0, значит работаем с глобальной таблицей.
; 8 - 0000 1000
; 16 - 0001 0000
; 32 - 0010 0000
; 92h - 0101 1100
; 98h - 0110 0010
DATA32 SEGMENT PARA 'DATA'
    ; Ранее мы описывали структуру, теперь мы явно выделяем память под каждый параметр.
    ; Данные дескрипторы описываются т.к. в защищённом режиме мы можем обращаться к сегментам используя только их (дескрипторы).

    ; Таблица глобальных дескрипторов GDT
    ; описал так, потому что было удобнее, так как порядок в таблице кроме нулевого не имеет значения
    GDT_NULL    SEGDESCR<0,0,0,0,0,0> ; нулевой дескриптор
    GDT_CODE16  SEGDESCR<CODE16_SIZE-1,0,0,98H,0,0> ; сегмент команд, 98h - задание attr_1 говорит о том, что это сегмент данных к которому
    ; запрещено обращение с целью записи и чтения
    GDT_DATA4GB SEGDESCR<0FFFFH,0,0,92H,0CFH,0> ; сегмент данных, 92h - задание attr_1, говорит о том, что это сегмент данных с разрешением
    ; записи и чтения

    ; * 0FFFFh - limit - 20-битный лимит сегмента. Максимально допустимое смещение при адресации с использованием этого сегмента
    ; * 0 - base adress l
    ; * 0 - base adress m
    ; * 92h - 1001 0010 - attr_1:
    ; 1 - P - признак присутствия сегмента в памяти (сегмент может быть выгружен менеджером виртуальной памяти) - 1
    ; 00 - DPL - привилегии дескриптора (0 = самые высокие, 3 = самые низкие) - самые высокие
    ; 1 - S - указывает, является ли дескриптор системным (1 = дескриптор не системный)
    ; 0010 - Type - (0EWA) 
    ; E - expansion direction - 0 - вверх, 1 - вниз, у нас вверх
    ; W - writable - 1 - разрешено и чтение и запись, иначе только чтение
    ; A - accessed - показывает, было ли обращение к дескриптору с момента последнего сброса этого флага.
    ; * 0CHh - 1100 1111
    ; 1 - G - указывает, в чём измеряется лимит - если 0 - в байтах, 1 - в страницах по 4 килобайта
    ; 1 - D/B - флаг, указывающий разрядность сегмента: 0 – сегмент 16-разрядный, 1 – сегмент 32 разрядный -> 32-х разрядный
    ; 0 - зарезервировано для 64 разрядного сегмента
    ; 0 - неиспользуемый бит. Может использоваться по усмотрению ОС.
    ; 1111 - limit (16-19)
    ; * 0 - base adress h
    

    GDT_CODE32  SEGDESCR<CODE32_SIZE-1,0,0,98H,40H,0> ; сегмент кода для реального режима, 98h - запрещена запись и чтение
    ; 40h - 0100 0000 - 0 - лимит в байтах, 1 - 32-х разрядный, 0 - резерв, 0 - неиспользуемый, 0000 - limit (16-19)
    GDT_DATA32  SEGDESCR<DATA_SIZE-1,0,0,92H,40H,0> ; сегмент данных для реального режима, 92h - разрешены запись и чтение
    GDT_STACK32 SEGDESCR<STACK_SIZE-1,0,0,92H,40H,0> ; сегмент стека - разрешены запись и чтение
    GDT_VIDEO16 SEGDESCR<3999,8000H,0BH,92H,0,0> ; видеопамять, attr_2 - там указываются тип дробности, в этом случае 0, т.к. граница в байтах,
    ; размер видеостраницы 4000 байт -> граница 3999, B8000h - базовый физический адрес страницы (8000h и Bh)
    ; Видеопамять в первом мегабайте адресного пространства, поэтому base_m = 0


    GDT_SIZE=$-GDT_NULL ; Размер таблицы, конец - нулевой дескриптор
    PDESCR    DF 0 ; Псевдодескриптор для команды lgdt
    ;lgdt - load global table descriptor - загрузить регистр глобальной таблицы

    ; Так как индекс селектора записывается с 3 бита, то это эквивалентно его умножению на 8, поэтому
    ; селекторы последовательных дескрипторов 0, 1, 2, 4 представляют собой числа 0, 8, 16, 24 ...
    ; Задание уровня привелегий в селекторе - 8 => 0000 0000 0000 1000
    CODE16S=8 ; селектор 8 (1)
    DATA4GBS=16 ; селектор 16 (2)
    CODE32S=24 ; селектор 24 (3)
    DATA32S=32 ; селектор 32 (4)
    STACK32S=40 ; селектор 40 (5)
    VIDEO16S=48 ; селектор 48 (6)

    IDT LABEL BYTE ; метка начата таблицы дескрипторов прерывания (IDT)

    ; 0 - 31 - исключения, внутренние прерывания
    ; дескрипторы должны быть расположены по порядку их векторов
    
    INTDESCR_0_12     INTDESCR 13 DUP (<0,CODE32S,0,8FH,0>) ; прерывания от 0 до 12
    ; 0 - смещение, заносится позже
    ; CODE32s - селектор, указывающий на дескриптор, описывающий 32-х разрядный сегмент кода
    ; 0 - счётчик
    ; 8Fh - 1000 1111:
    ; P = 1 - присутствует (бит присутствия)
    ; Этот бит показывает, может ли элемент таблицы использоваться при трансляции адреса.
    ; 00 - уровень привелегий (DPL)
    ; S - 0 - системный объект
    ; 1111 - F : F - шлюз ловушки, служит для обработки исключений 
    ; и программных прерываний

    INTDESCR_13       INTDESCR <0,CODE32S,0,8FH,0> ; исключение общей защиты, выделяется отдельно, чтобы можно было
    ; в дальшейшем также отдельно обработать, так как в нём нужно учитывать код ошибки
    INTDESCR_14_31    INTDESCR 18 DUP (<0,CODE32S,0,8FH,0>)
    ; 14 - 31

    ; Отедльно описываем шлюзы 08h и 09h
    ; 10001110 - Eh - служит для обработки прерывания
    INT08 INTDESCR <0,CODE32S,0,10001110B,0> 
    INT09 INTDESCR <0,CODE32S,0,10001110B,0>

    IDT_SIZE=$-IDT  ; размер таблицы дескрипторов прерываний

    ; interruption psevdo descriptor
    ; DF - выделить поле для псевдодескриптора (6-байт).
    IPDESCR     DF 0

    ; Псевдодескриптор таблицы прерываний для реального
    ; режима (адрес = 0; размер - 3FF + 1 = 400h, то есть 1024 байта, то есть первый килобайт)
    IPDESCR16   DW 3FFH, 0, 0

    ; маски прерываний для ведущего и ведомого контроллера прерываний, используются для управления прерываниями
    MASK_MASTER DB 0        
    MASK_SLAVE  DB 0        
    
    ASCIIMAP   DB 0, 0, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 0, 0
    DB 81, 87, 69, 82, 84, 89, 85, 73, 79, 80, 91, 93, 0, 0, 65, 83
    DB 68, 70, 71, 72, 74, 75, 76, 59, 39, 96, 0, 92, 90, 88, 67
    DB 86, 66, 78, 77, 44, 46, 47 ; карта кодов ascii символов для вывода символов

    PR_FLAG     DB 0 ; флаг защищённого режима
    CNT_TIME    DB 0 ; счётчик времени

    SYML_POS    DD 2 * 80 * 5 ; позиция символа на экране

    INTERVAL=10 ; интервал мигания таймера

    MEM_POS=30*2 ; позиция на экране слова memory
    MEM_VALUE_POS=36*2 ; позиция значения памяти
    MB_POS=45*2 ; позиция вывода слова MB
    CURSOR_POS=80*2*2+38*2 ; позиция курсора 80 * 2 - длина строки
    PARAM=21H ; 

    CURSOR_SYMB_ON=221 ; цвет вкл
    CURSOR_SYMB_OFF=222 ; цвет выкл
    
    ; сообщения
    RM_MSG      DB 27, 'NOW IN REAL MODE'
    PM_MSG_WAIT DB 27, '[43;1m!PRESS ANY KEY TO ENTER PROTECTED MODE!', 27, '[0m$'
    PM_MSG_OUT  DB 27, '[43;1m!NOW IN REAL MODE AGAIN! ', 27, '[0m$'

    DATA_SIZE=$-GDT_NULL ; размер сегмента данных
DATA32 ENDS

CODE32 SEGMENT PARA PUBLIC 'CODE' USE32 ; устанавливаем регистры
    ASSUME CS:CODE32, DS:DATA32, SS:STACK32

PM_START:
    ; загружаем сегменты памяти
    MOV AX, DATA32S
    MOV DS, AX
    MOV AX, VIDEO16S
    MOV ES, AX
    MOV AX, STACK32S
    MOV SS, AX
    MOV EAX, STACK_SIZE
    MOV ESP, EAX

    STI ; разрешаем аппаратные прерываний
       
    ; вывод сообщения memory
    MOV DI, MEM_POS
    MOV AH, PARAM

    MOV AL, 'M'
    STOSW ; посылает содержимое AX в память, адресуемое DI в ES
    MOV AL, 'E'
    STOSW
    MOV AL, 'M'
    STOSW
    MOV AL, 'O'
    STOSW
    MOV AL, 'R'
    STOSW
    MOV AL, 'Y'
    STOSW
    MOV AL, ':'
    STOSW

    CALL COUNT_MEM ; вызов процедуры подсчёта памяти
    
    PROCCESS: ; тестирование флага защищённого режима
        TEST PR_FLAG, 1 ; пока 1 продолжается
        JZ  PROCCESS
    
    CLI ; запрет аппаратных прерываний

    DB  0EAH ; код команды far jump
    DD  OFFSET RETURN_RM ; прыжок на RETURN_RM
    DW  CODE16S ; сегмент кода - CODE 16

    EXCEPT_1 PROC ; заглушка для исключений
        IRET
    EXCEPT_1 ENDP

    EXCEPT_13 PROC USES EAX ; обработчик исключения общей защиты, снимаем со стека код ошибки
        POP EAX
        IRET
    EXCEPT_13 ENDP

    NEW_INT08 PROC USES EAX ; обработчик 08h
        MOV EDI, CURSOR_POS ; в EDI позицию для вывода
        CMP CNT_TIME, INTERVAL ; сравним сремя с интервалом
        JE X ; если 0, то прыжок на включение курсора
        CMP CNT_TIME, INTERVAL*2 ; сравнение с двойным интервалом
        JNE SKIP ; если не 0, то на skip

        MOV AL, CURSOR_SYMB_OFF ; выключаем курсор
        MOV CNT_TIME, 0 ; обнуляем таймер
        JMP PR ; прыжок на PR
        X: ; включение курсора
            MOV AL, CURSOR_SYMB_ON ; Символ, который мы хотим вывести (в моем случае просто квадрат).
        PR: ; заносим в EDI 21h
            MOV AH, PARAM
            STOSW ; al (символ) с параметром (ah) перемещается в область памяти es:di

        ; увеличиваем таймер
        SKIP: 
            MOV  AL, CNT_TIME
            INC AL
            MOV CNT_TIME, AL
        
        ; используется только в аппаратных прерываниях для корректного завершения
        ; (разрешаем обработку прерываний с меньшим приоритетом)!!

            MOV AL, 20H 
            OUT 20H, AL

            IRETD ; double - возвратный адрес - 32 бит iret
    NEW_INT08 ENDP

    NEW_INT09 PROC USES EAX EBX EDX
        IN  AL, 60H ; считывание порта клавиатуры
        CMP AL, 1CH ; сравнение с enter

        JNE PRINT_VALUE ; прыжок на вывод 
        OR PR_FLAG, 1 ; если enter, то флаг вывода
        JMP ALLOW_KB ; прыжок на разрешение kb

    PRINT_VALUE:
        CMP AL, 80H ; проверка на то, отпущена ли клавиша
        JA ALLOW_KB     

        XOR AH, AH ; очистка AH и EBX

        XOR EBX, EBX
        MOV BX, AX

        MOV DH, PARAM ; Вывод значения из карты под индексом [EBX]
        MOV DL, ASCIIMAP[EBX]   
        MOV EBX, SYML_POS   
        MOV ES:[EBX], DX

        ADD EBX, 2          
        MOV SYML_POS, EBX ; смещение позиции печати

    ALLOW_KB:
        IN  AL, 61H ; сохранение старших битов порта клавиатуры
        OR  AL, 80H 
        OUT 61H, AL
        AND AL, 7FH ; 
        OUT 61H, AL

        ; разрешаем обработку прерываний с меньшим приоритетом для корректного завершения
        MOV AL, 20H 
        OUT 20H, AL

        IRETD
    NEW_INT09 ENDP

    COUNT_MEM PROC USES DS EAX EBX
        MOV AX, DATA4GBS ; используем данные 4 гига
        MOV DS, AX ; в сегменты регистр помещаетя селектор gdt_data4gb
        ; и в этот же момент в теневой регистр помещается дескриптор gdt_data4gb

        ; перепрыгиваем первый мегабайт (2^20) так как там лежит наша программа
        ; если мы затрём програму, то она сдохнет
        MOV EBX,  100001H
        ; некоторе значение, с которого проверяется запись
        MOV DL,   0AEH

        MOV ECX, 0FFEFFFFEH ; Это оставшееся FFEF FFFE + 10 0001 = F0000 0000 ==  (2^4)^8 = 2^32  = 4 Гб

        ; Из методы:
        ; В защищенном режиме определить объем доступной физической
        ; памяти следующим образом – первый мегабайт пропустить;
        ; начиная со второго мегабайта сохранить байт или слово памяти, 
        ; записать в этот байт или слово сигнатуру, прочитать сигнатуру и 
        ; сравнить с сигнатурой в программе, если сигнатуры совпали, то это – память.
        ; Вывести на экран полученной количество байтов доступной памяти.

        ITER_MEM: ; проход по памяти
            MOV DH, DS:[EBX] ; ds:[ebx] - линейный адрес вида 0 + ebx
            ; бежим с помощью ebx

            MOV DS:[EBX], DL ; записываем сигнатуру по этому адресу
            CMP DS:[EBX], DL ; сравниваем сигнаруту с сигнатурой в программе
        
            JNZ PRINT_MEM ; сравниваем с 0, если не 0 - не наша память, печатаем сколько получилось

            MOV DS:[EBX], DH ; обратно записываем считанное значение
            INC EBX ; увелчиваем счётчик
        LOOP ITER_MEM

        PRINT_MEM:
            MOV EAX, EBX ; записываем значение в EAX
            XOR EDX, EDX ; сбрасываем EDX

            MOV EBX, 100000H ; перевод в мегабайты, 16^2 = 2^20
            DIV EBX ; делим eax / ebx -> eax содержит кол-во мегабайт

            ; Смена места вывода.
            MOV EBX, MEM_VALUE_POS
            CALL PRINT_EAX ; вызов вывода

            ; Смена места вывода. Выводим надпись (MB)
            MOV AH, PARAM
            MOV EBX, MB_POS
            MOV AL, 'M'
            MOV ES:[EBX], AX

            MOV EBX, MB_POS + 2
            MOV AL, 'B'
            MOV ES:[EBX], AX
            RET
    COUNT_MEM ENDP
        
    PRINT_EAX PROC USES ECX EBX EDX ; вывод значения в eax
        ; в eax - кол-во мегабайт
        ; в ebx - mem_value_pos
        ADD EBX, 10H ; сдвигаем ebx на 8 
        MOV ECX, 8 
        MOV DH, PARAM ; в DH - 21h

        PRINT_SYMBOL:
            MOV DL, AL ; Получение младшей части dl
            AND DL, 0FH ; AND с 0000 1111 -> 4 бита - 16-ричная цифра

            CMP DL, 10 ; сравнение с 10
            JL ADD_ZERO_SYM ; если меньше 10, просто выводим эту цифру
            ADD DL, 'A' - '0' - 10 ; если больше, то вычитаем 10

        ADD_ZERO_SYM: 
            ADD DL, '0' ; превращаем в строковое представление
            MOV ES:[EBX], DX ; помещаем в видеобуфер dx
            ROR EAX, 4 ; циклически сдвигаем на 4, чтобы на следующей операцией работать со
            ; следующей цифрой, убираем последнюю 16-ричную цифру eax
            ; 2 - тк. байт атрибутов и байт самого символа
            SUB EBX, 2 ; переходим к левой ячейке видеопамяти
        LOOP PRINT_SYMBOL

        RET
    PRINT_EAX ENDP

    CODE32_SIZE = $-PM_START ; размер сегмента кодв
CODE32 ENDS

; начало работы программы
CODE16 SEGMENT PARA PUBLIC 'CODE' USE16 ; объявление сегмента
ASSUME CS:CODE16, DS:DATA32, SS: STACK32 ; назначение регистров
START: ; метка начала работы программы
    MOV AX, DATA32 ; устанавливаем DS на DATA32
    MOV DS, AX

    MOV AH, 09H ; команда вывода сообщения
    LEA DX, RM_MSG ; передаём в DX эффективный адрес сообщения о защищённом режиме
    ; с помощью LEА
    INT 21H ; вывод сообщения

    XOR DX, DX ; очистка DX
    MOV AH, 2 ; команда вывода символа на экран
    MOV DL, 13 ; возврат каретки
    INT 21H
    MOV DL, 10 ; перевод строки
    INT 21H

    MOV AH, 09H ; вывод сообщения об ожидании нажатия для перевода в з.р.
    LEA DX, PM_MSG_WAIT
    INT 21H
    XOR DX, DX ; очистка DX
    MOV AH, 2 ; возврат каретки и перевод строки
    MOV DL, 13
    INT 21H
    MOV DL, 10
    INT 21H

    ; Ожидание нажатия.
    MOV AH, 10H
    INT 16H
    
    ; Очистка экрана.
    MOV AX, 3
    INT 10H

    XOR EAX, EAX ; очистка EAX

    MOV AX, CODE16 ; заносим сегмент CODE16 в AX
    SHL EAX, 4 ; сдвигаем EAX влево на 4 чтобы 0000 0000 0000 0000
    MOV WORD PTR GDT_CODE16.BASE_L, AX ; заносим в младшее слово GDT_CODE16
    SHR EAX, 16 ; сдвигаем на 16 вправо
    MOV BYTE PTR GDT_CODE16.BASE_M, AL ; заносим в среднее слово  
    MOV BYTE PTR GDT_CODE16.BASE_H, AH ; заносим в старшее слово

    ; аналогичным образом заносим данные всех сегментов в глобальную
    ; таблицу дескприторов

    ; EAX
    ; -- AX
    ; - - AL AH
    ; 0000 0000 | 0000 0000 | xxxx xxxx | xxxx xxxx

    MOV AX, CODE32 ; 0000 0000 | 0000 0000 | xxxx xxxx | xxxx xxxx
    SHL EAX, 4     ; 0000 0000 | 0000 xxxx | xxxx xxxx | xxxx 0000                 
    MOV WORD PTR GDT_CODE32.BASE_L, AX  
    SHR EAX, 16                       ; 0000 0000 | 0000 0000 | 0000 0000 | 0000 xxxx
    MOV BYTE PTR GDT_CODE32.BASE_M, AL  
    MOV BYTE PTR GDT_CODE32.BASE_H, AH  

    MOV AX, DATA32
    SHL EAX, 4                        
    MOV WORD PTR GDT_DATA32.BASE_L, AX  
    SHR EAX, 16                       
    MOV BYTE PTR GDT_DATA32.BASE_M, AL  
    MOV BYTE PTR GDT_DATA32.BASE_H, AH  

    MOV AX, STACK32
    SHL EAX, 4                        
    MOV WORD PTR GDT_STACK32.BASE_L, AX  
    SHR EAX, 16                       
    MOV BYTE PTR GDT_STACK32.BASE_M, AL  
    MOV BYTE PTR GDT_STACK32.BASE_H, AH  

    ; Вычисляем и загружаем линейный адрес GDT в EAX
    MOV AX, DATA32 ; 0000 0000 | 0000 0000 | xxxx xxxx | xxxx xxxx
    SHL EAX, 4     ; 0000 0000 | 0000 xxxx | xxxx xxxx | xxxx 0000 
    ADD EAX, OFFSET GDT_NULL ; 0000 0000 | 0000 xxxx | xxxx xxxx | xxxx 0000 

    ; заносм EAX в псевдодескриптор lgdt
    MOV DWORD PTR PDESCR+2, EAX ; База GDT
    MOV WORD PTR  PDESCR, GDT_SIZE-1 ; Граница GDT
    LGDT FWORD PTR PDESCR ; загружаем PDESCR в GDTR

    ; загружаем значения меток прерываний в таблицу перерываний с учётом разницы 16-32
    LEA EAX, ES:EXCEPT_1
    MOV INTDESCR_0_12.OFFS_L, AX 
    SHR EAX, 16             
    MOV INTDESCR_0_12.OFFS_H, AX 

    LEA EAX, ES:EXCEPT_13
    MOV INTDESCR_13.OFFS_L, AX 
    SHR EAX, 16             
    MOV INTDESCR_13.OFFS_H, AX 

    LEA EAX, ES:EXCEPT_1
    MOV INTDESCR_14_31.OFFS_L, AX 
    SHR EAX, 16             
    MOV INTDESCR_14_31.OFFS_H, AX 

    LEA EAX, ES:NEW_INT08
    MOV INT08.OFFS_L, AX
    SHR EAX, 16
    MOV INT08.OFFS_H, AX

    LEA EAX, ES:NEW_INT09
    MOV INT09.OFFS_L, AX 
    SHR EAX, 16             
    MOV INT09.OFFS_H, AX 

    ; Вычисляем и загружаем линейный адрес IDT в EAX
    MOV AX, DATA32
    SHL EAX, 4
    ADD EAX, OFFSET IDT

    ; Загружаем IDT
    MOV  DWORD PTR IPDESCR + 2, EAX ; База IDT
    MOV  WORD PTR  IPDESCR, IDT_SIZE-1 ; Граница IDT
    
    ; Сохранение масок.
    IN  AL, 21H                     
    MOV MASK_MASTER, AL             
    IN  AL, 0A1H                    
    MOV MASK_SLAVE, AL
    
    ; Перепрограммирование ведущего контроллера.
    ; мы это делаем по причине того, что в защищённом режиме номера от 
    ; 08h до 0Fh зарезервированы для обработки исключений
    ; поэтому мы перепрограммируем контроллер на другой диапазон номеров векторов 
    ; аппаратных прерываний
    MOV AL, 11H ; СКИ1 на СКИ3 
    ; СКИ - слово команды инициализации, всего три вида - СКИ1, СКИ2, СКИ3
    OUT 20H, AL                     
    MOV AL, 32 ; СКИ2 - базовый вектор
    OUT 21H, AL                     
    MOV AL, 4 ; СКИ3 - подключение ведомого к уровню 2
    OUT 21H, AL
    MOV AL, 1 ; СКИ4 80х8, требуется EOI
    OUT 21H, AL

    ; Маска для ведущего контроллера.
    MOV AL, 0FCH
    OUT 21H, AL

    ; Маска для ведомого контроллера (запрет прерываний).
    MOV AL, 0FFH
    OUT 0A1H, AL
    
    LIDT FWORD PTR IPDESCR ; загрузка IPDESCR в IDTR                         
    
    ; Открытие линии А20.
    IN  AL, 92H
    OR  AL, 2
    OUT 92H, AL

    CLI ; запрет аппаратных прерываний (маскируемых)

    ; переход в защищённый режим
    MOV EAX, CR0
    OR EAX, 1 ; бит перевода
    MOV CR0, EAX ; перевод

    ; префик 66h - следующая команда с другой разрядностью чем указано в use16
    DB  66H 
    DB  0EAH ; код far jump
    DD  OFFSET PM_START ; смещение к protected mode
    DW  CODE32S ; сегмент

RETURN_RM: ; метка возврата из защищённого режима
    MOV EAX, CR0 ; флаг CR0 возвращается к режим защищённого режима
    AND AL, 0FEH                
    MOV CR0, EAX
    
    DB  0EAH ; команда прыжка
    DW  OFFSET GO ; адрес - GO
    DW  CODE16 ; сегмент - CODE 16

GO: ; возвращение в реальный режим
    ; обновление всех сегментых регистров
    MOV AX, DATA32   
    MOV DS, AX
    MOV AX, CODE32
    MOV ES, AX
    MOV AX, STACK32   
    MOV SS, AX
    MOV AX, STACK_SIZE
    MOV SP, AX
    
    ; восстановление контроллера прерываний 
    MOV AL, 11H
    OUT 20H, AL
    MOV AL, 8
    OUT 21H, AL
    MOV AL, 4
    OUT 21H, AL
    MOV AL, 1
    OUT 21H, AL

    ; восстановление масок прерываний
    MOV AL, MASK_MASTER
    OUT 21H, AL
    MOV AL, MASK_SLAVE
    OUT 0A1H, AL

    ; восстановление вектора прерываний - возвращение на первый килобайт
    LIDT    FWORD PTR IPDESCR16

    ; закрытие линии А20, если не закрыть, то в реальном режиме может быть адресовано ещё 64кб памяти
    IN  AL, 70H 
    AND AL, 7FH
    OUT 70H, AL

    STI ; разрешение аппаратных прерываний
    
    ; Очистка экрана.
    MOV AX, 3
    INT 10H

    ; Вывод сообщения об успешном переходе в реальный режим
    MOV AH, 09H
    LEA DX, PM_MSG_OUT
    INT 21H
    XOR DX, DX
    MOV AH, 2
    MOV DL, 13
    INT 21H
    MOV DL, 10
    INT 21H

    ; конец программы
    MOV AX, 4C00H
    INT 21H

    CODE16_SIZE = $-START  
CODE16 ENDS

END START