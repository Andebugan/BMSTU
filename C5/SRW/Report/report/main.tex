\chapter{Анализ предметной области}
Ф-2 – это эмоциональный робот, разрабатываемый командой российских исследователей, обладающий умением общаться с людьми. С его помощью можно разрабатывать стратегии диалога, мимику и жесты, изменения направления взгляда и многое другое. Робот сделан максимально простым, чтобы его можно было легко собрать. Использование данной платформы позволяет исследовать эмоциональный контакт, возникающий за счёт поведения робота, а не за счёт его внешнего вида. Робот напоминает мультипликационных персонажей, которые совсем не похожи на человека, но при этом эмоциональны и симпатичны благодаря своим жестам и мимике, а не из-за внешнего сходства с человеком. Робот реагирует на слова: он принимает на вход текст на естественном языке, строит смысл этого текста, выбирает эмоцию и выполняет жесты, характерные для этой эмоции. Когнитивный компонент робота отвечает за мышление и за понимание текста. Для входящего высказывания когнитивный компонент должен построить некоторый набор умозаключений, выбрать эмоции, которые может вызывать текст, чтобы далее проявить эти эмоции в поведении робота. Робот может читать книги в виде текстовых файлов, новости и блоги через подписку RSS, воспринимать устную речь через сторонний сервис преобразования в письменную форму. По письменному тексту для каждого предложения когнитивный компонент строит синтаксическое дерево, а затем конструирует семантическое представление – смысл текста. Смысл текста вызывает у робота различные умозаключения, выводы и ответные реакции. Эти процессы моделируются системой отношений типа «если-то» – сценариев. Робот сравнивает смысл поступившего текста с посылками всех сценариев и активизирует ближайшие сценарии. Смысл поступившего текста может активизировать сценарии, ответственные за эмоциональную обработку – Меня никто не любит, Я никому не нужен или, наоборот, Приятно быть в центре внимания. Когнитивный компонент может работать отдельно от робота: он будет прочитывать множество текстов, конструировать их смысл, приписывать каждому смыслу эмоцию и сохранять результаты. При управлении роботом каждый сценарий может сформировать поведенческий пакет на языке BML и передать его роботу для выполнения. Таким образом, поведение робота составляется из BML-пакетов – реакций на окружающие события или просто движений в состоянии покоя: когда роботу нечего делать, он будет слегка двигаться \cite{f2}. \\

Одной из проблем данного робота является невозможность проводить эксперименты без наличия физической копии робота. Решить данную проблему представляется возможным при помощи создания виртуальной среды, которая позволит эмулировать робота Ф-2 и набор из различных человеческих входов (положение головы, эмоции, которые данный вход показывает на лице и ограниченная мимика и жестикуляция).\\

Создание подобной виртуальной среды будет иметь следующие применения в проекте Ф-2.
\begin{enumerate}
	\item будет предоставлена возможности воспроизведения реакций робота в тестовом режиме на этапе разработки элементов реакции или набора реакций, воспроизводимых совместно;
	\item станет возможной постановка экспериментов по взаимодействию робота с респондентами в виртуальном режиме. Это позволит проводить больше экспериментов по коммуникации и, следовательно, получать больше обратной связи от респондентов, в том числе позволит респондентам взаимодействовать с роботом удалённо вместо того или вместе с тем, чтобы приезжать к роботу;
	\item станет возможным проводить параллельные эксперименты по коммуникации человека и робота, что позволит объединить усилия множества респондентов, что приведет к более интенсивному развитию проекта на материале собранной обратной связи.
\end{enumerate}

Таким образом целью данной работы является проектирование описанной выше виртуальной среды. Для того, чтобы достичь поставленной цели, необходимо выполнить следующие задачи:
\begin{enumerate}
	\item провести анализ предметной области и сформировать основные требования к алгоритмам, которые будут использоваться в реализации вирутальной среды для робота Ф-2;
	\item выбрать алгоритмы на основе проведённого выше анализа и описать принципы их работы;
	\item оценить существующие решения данной задачи;
	\item описать используемые в данных алгоритмах структуры данных;
	\item привести схемы рассматренных выше алгоритмов;
	\item описать структуру разрабатываемого ПО;
\end{enumerate}

\chapter{Классификация существующих решений}

\chapter{Построение прототипа метода}
В данном разделе рассматриваются трёхмерная виртуальная среда и объекты, которые в ней содержатся.

\section{Формализация трёхмерной виртуальной среды}
В данном подразделе рассматриваются объекты трёхмерной виртуальной среды, описываются их характеристики и описываются отношения между объектами.

\subsection{Анализ виртуальной сцены}
Основным объектом трёхмерной виртуальной среды является сцена - виртуальное трёхмерное пространство, являющееся базовым объектом трёхмерной виртуальной среды.

Сцена может содержать в себе следующие объекты:
\begin{itemize}
	\item Виртуальный аватар робота Ф-2;
	\item Виртуальная камера;
	\item Аватар пользователя.
\end{itemize}

\subsection{Анализ виртуального аватара робота Ф-2}
Виртуальный аватар робота Ф-2 - объект сцены трёхмерной виртуальной среды, являющийся представлением реального прототипа робота Ф-2.  Для того, чтобы получить возможность проводить эксперименты с виртуальным аватаром робота Ф-2, необходимо эмулировать данные, подающиеся на вход роботу и реакцию робота на полученные данные. При обработке информации робот Ф-2 использует два входных параметра - фразу на естественном языке и положение лица собеседника. \cite{f2} \\

Естественный язык - в лингвистике и философии языка язык, используемый для общения людей (в отличие от формальных языков и других типов знаковых систем, также называемых языками в семиотике) и не созданный целенаправленно (в отличие от искусственных языков). \cite{lang}\\

Необходимые данные виртуальный аватар робота получает от виртуального аватара пользователя. Положение аватара пользователя является положением лица собеседника. Фраза на естественном языке передаётся роботу в виде строки, помеченной как ввод от данного пользователя.\\

По причине того, что реакция робота на поданные на вход данные представляет из себя изменения положения тела робота и выражения "лица", то на виртуальной сцене робот Ф-2 представляется в виде серии трёхмерных примитивов, образующих основные элементы геометрии робота Ф-2, которые включают в себя основание робота, левую и правую конечности, шею и голову с дисплеем. Помимо эмуляции положения сочленений робота в пространстве также необходимо эмулировать различные эмоции на лице робота, что достигается использованием двумерной текстуры, которая затем накладывается на одну из плоскостей трёхмерного примитива, являющегося представлением экрана робота Ф-2.

\subsection{Анализ виртуальной камеры}
Виртуальная камера - объект сцены трёхмерной виртуальной среды, эмулирующий камеру в трёхмерном пространстве сцены и позволяющий получать двумерный снимок (проекцию) сцены.

3D-проекция (или графическая проекция)-это метод проектирования, используемый для отображения трехмерного (3D) объекта на двумерной (2D) поверхности. Эти проекции основаны на визуальной перспективе и анализе аспектов, чтобы спроецировать сложный объект для возможности просмотра на более простой плоскости. \cite{petty}\\

Существует два основных вида проецирования:
\begin{itemize}
\item - параллельная проекция;\\
\item - перспективная проекция.\\
\end{itemize}

Параллельная проекция - это проекция объекта в трехмерном пространстве на неподвижную плоскость, известную как плоскость проекции или плоскость изображения, где лучи, известные как линии обзора или проекционные линии, параллельны друг другу. 

Перспективная проекция - это приблизительное представление, обычно на плоской поверхности, изображения таким, каким оно видится глазу.

В случае виртуальной камеры для трёхмерной виртуальной среды будет использоваться перспективная проекция для того, чтобы позволить пользователям, использующим редактор для проведения экспериментов с виртуальным аватаром робота Ф-2, интуитивно понимать, каким образом объекты сцены расположены относительно друг друга.

\subsection{Анализ виртуального аватара пользователя}
Виртуальный аватар пользователя - объект сцены трёхмерной виртуальной среды, эмулирующий пользователя в трёхмерном пространстве сцены и позволяющий симулировать работу робота Ф-2.

Объект пользователя представляется на виртуальной сцене как трёхмерный примитив. Положение данного примитива в пространстве является положением лица пользователя, которое передаётся на вход виртуальному аватару робота Ф-2. Также объект пользователя позволяет формировать и отправлять роботу строки, содержащие фразы на естественном языке и помеченное как сообщение от данного пользователя.

\section{Анализ методов, необходимых для формирования и отрисовки трёхмерного объекта}
В данном подразделе рассматриваются методы, использующиеся формирования и отрисовки трёхмерных объектов, находящихся в пространстве виртуальной сцены.

\subsection{Анализ способа представления поверхности}
При рассмотрении того, каким образом можно задать некоторую поверхность в пространстве виртуальной сцены выделяется три основных способа:
\begin{itemize}
	\item каркасный — модель представляется в виде множества вершин, связанных между собой рёбрами;
	\item поверхностный — модель представляется в виде множества поверхностей;
	\item объёмный — модель формируется из элементарных объектов (базисных тел) с использованием логических операций объединения, вычитания, пересечения.
\end{itemize}

Для того, чтобы представить трёхмерные примитивы, используется поверхностный способ описания модели, так как каркасные модели не обладают достаточным количеством деталей, что отрицательно скажется на читабельности сцены в процессе экспериментов. Объёмные модели не имеют смысла, поскольку работа ведётся не с объёмом модели, а только с её поверхностью.\\

Поверхностную модель мы можем задать следующими способами:

Параметрическое представление— поверхность определяется некой функцией, зависящей от одного или нескольких параметров. В основном данный метод используется для задания в трёхмерном пространстве объектов вращения.\\

Полигональная сетка — в этом случае поверхность задаётся совокупностью вершин, рёбер и граней, которые определяют внешний вид объекта.\\

Параметрическое представление не подходит, так как представление в сцене объектов, не являющихся объектами вращения будет затруднительно. В свою очередь полигональная сетка является универсальным форматом представления модели, позволяющим легко представить практически любые формы в трёхмерном пространстве и имеющим широкое применение в современном трёхмерном моделировании.\\

Полигональная сетка может быть реализована несколькими разными способами:
\begin{itemize}
	\item Вершинное представление — в этом случае формируется список, в котором для каждой вершине ставятся в соответствие вершины, с которыми она соединена рёбрами.
	\item Таблица углов — в данном случае вершины хранятся в предопределённой таблице. 
	\item Список граней — представляет объект как множество граней и вершин.
	\item Список полигонов — представляет объект как множество поверхностей, формирующих поверхность модели. 
\end{itemize}

Так как виртуальная среда должна работать в режиме реального времени, то вершинное представление не используется, поскольку для того, чтобы сформировать грани необходимо пройти по данным несколько раз, что сказывается на производительности программы. По той же причине не используется таблица углов, поскольку изменение данных является затратным по времени.\\

Для решения данной задачи будет использоваться список треугольных полигонов, которые в совокупности будут составлять поверхность модели. Данный является наиболее подходящим, так как треугольник в пространстве однозначно задаёт плоскость, вследствие чего алгоритмы работы с ним реализуются легче и работают быстрее, чем с произвольными полигонами.

\subsection{Анализ алгоритмов удаления невидимых линий и поверхностей}

При выборе алгоритма удаления невидимых линий и поверхностей нужно учитывать особенности поставленной задачи. Одной из таких особенностей является то, что нам не нужно реалистическое изображение, поскольку для обозначения положения в виртуальном пространстве сцены аватара робота и аватаров пользователя достаточно нескольких трёхмерных примитивов, позволяющих схематически отображать состояние объектов на сцене. При этом не использование сложных алгоритмов не предпочтительно, поскольку это приведёт к излишним затратам по времени и как следствие - к замедлению работы программы.\\

Алгоритм трассировки лучей — при построении изображения луч посылается в заданном направлении для оценки приходящей оттуда световой энергии. Эта энергия определяется освещённостью первой поверхности, встретившейся на пути луча. Из каждого источника света выпускаются лучи во все стороны. При пересечении луча с поверхностью получаются отражённый и преломлённый лучи, а если моделировать диффузное освещение, то и пучок лучей, равномерно распространяющийся во все стороны. Данный метод имеет наивысшую степень реализма и вместе с этим высокую сложность реализации и затрат ресурсов при работе программы. \cite{cgshish}\\

Алгоритм Робертса — Алгоритм Робертса представляет собой первое известное решение задачи об удалении невидимых линий. Это математически элегантный метод, работающий в объектном пространстве. Алгоритм прежде всего удаляет из каждого тела те ребра или грани, которые экранируются самим телом. Пусть F – некоторая грань многогранника. Плоскость, несущая эту грань, разделяет пространство на два подпространства. Назовем положительным то из них, в которое смотрит внешняя нормаль к грани. Если точка наблюдения – в положительном подпространстве, то грань – лицевая, в противном случае – нелицевая. Если многогранник выпуклый, то удаление всех нелицевых граней полностью решает задачу визуализации с удалением невидимых граней. Невыпуклые тела должны быть разбиты на выпуклые части. В этом алгоритме выпуклое многогранное тело с плоскими гранями должно представиться набором пересекающихся плоскостей. \cite{cgshish}\\

Алгоритм Варнака — алгоритм Варнака является ещё одним примером алгоритма, основанного на разбиении картинной плоскости на части, для каждой из которых исходная задача может быть решена достаточно просто. Разобьём видимую часть картинной плоскости на 4 равные части. В случаях, когда часть полностью накрывается проекцией ближайшей грани и часть не накрывается проекцией ни одной грани, вопрос о закрашивании соответствующей части решается тривиально. В случае, когда ни одно из этих условий не выполнено, данная часть разбивается на 4 части, для каждой их которых проверяется выполнение этих условий, и так далее. Очевидно, что разбиение имеет смысл проводить до тех пор, пока размер части больше, чем размер пиксела. \cite{cgshish_2}\\

Алгоритм, использующий Z-буфер — данный алгоритм является одним из простейших алгоритмов удаления невидимых поверхностей. Работает этот алгоритм в пространстве изображения. Идея Z-буфера является простым обобщением идеи о буфере кадра. Буфер кадра используется для запоминания атрибутов (интенсивности) каждого пиксела в пространстве изображения, Z-буфер – это отдельный буфер глубины, используемый для запоминания координаты z или глубины каждого видимого пиксела в пространстве изображения. В процессе работы глубина или значение z каждого нового пиксела, который нужно занести в буфер кадра, сравнивается с глубиной того пиксела, который уже занесен в Z-буфер. Если это сравнение показывает, что новый пиксел расположен впереди пиксела, находящегося в буфере кадра, то новый пиксел заносится в этот буфер и, кроме того, производится корректировка Z-буфера новым значением z. Если же сравнение дает противоположный результат, то никаких действий не производится. По сути, алгоритм является поиском по х и у наибольшего значения функции z(х, у). \cite{cgshish}\\

Поскольку в данной задаче важна скорость построения изображения для динамической отрисовки происходящего на экране, используется алгоритм z-буфера.

\subsection{Анализ методов закрашивания}

В компьютерной графике для расчета освещенности граней объектов применяется цветовая модель RGB. Интенсивность отраженного света точек объектов вычисляют отдельно для каждой их трех составляющих цветовых компонент, а затем объединяют в результирующую тройку цветов. При расчете освещенности граней применяют следующие типы освещения и отражения света от поверхностей: 

\begin{itemize}
\item рассеянное;
\item диффузное;
\item зеркальное.
\end{itemize}

Матовые поверхности обладают свойством диффузного отражения, т. е. равномерного по всем направлениям рассеивания света. Поэтому кажется, что поверхности имеют одинаковую яркость независимо от угла обзора. Для таких поверхностей справедлив закон косинусов Ламберта, устанавливающий соответствие между количеством отраженного света и косинусом угла $\theta$ между направлением на точечный источник света интенсивности $I_{p}$ и нормалью к поверхности. При этом количество отраженного света не зависит от положения наблюдателя. Освещенность рассеянным светом вычисляется по формуле. \ref{light_dist}
\begin{equation}\label{light_dist} 
I_{d} = I_{p} \cdot k_{d} \cdot cos \theta.
\end{equation}
Значение коэффициента диффузного отражения $k_{d}$ является константой в диапазоне (0, 1) и зависит от материала \cite{belcg}.\\

Закраска по Гуро — алгоритм закраски поверхности по Гуро позволяет устранить дискретность изменения интенсивности. Процесс закраски по методу Гуро осуществляется в четыре этапа:
\begin{enumerate}
\item вычисляются нормали ко всем полигонам;
\item определяются нормали в вершинах путем усреднения нормалей по всем полигональным граням, которым принадлежит вершина;
\item используя нормали в вершинах и применяя произвольный метод закраски, вычисляются значения интенсивности в вершинах;
\item Каждый многоугольник закрашивается путем линейной интерполяции значений интенсивностей в вершинах сначала вдоль каждого ребра, а затем и между ребрами вдоль каждой сканирующей строки.
\end{enumerate}

Закраска по Фонгу — В методе закраски Фонга используется интерполяция вектора нормали к поверхности вдоль видимого интервала на сканирующей строке внутри многоугольника, а не интерполяция интенсивности. Интерполяция выполняется между начальной и конечной нормалями, которые сами тоже являются результатами интерполяции вдоль ребер многоугольника между нормалями в вершинах. Нормали в вершинах, в свою очередь, вычисляются так же, как в методе закраски, построенном на основе интерполяции интенсивности. В каждом пикселе вдоль сканирующей строки новое значение интенсивности вычисляется с помощью любой модели закраски. Заметные улучшения по сравнению с интерполяцией интенсивности наблюдаются в случае использования модели с учетом зеркального отражения, т. к. при этом более точно воспроизводятся световые блики. Однако даже если зеркальное отражение не используется, интерполяция векторов нормали приводит к более качественным результатам, чем интерполяция интенсивности, поскольку аппроксимация нормали в этом случае осуществляется в каждой точке. \cite{belcg}\\

В данной задаче использовать сложные закраски с применением интерполяции смылса не имеет, так как основной целью виртуальной трёхмерной среды является симуляция работы робота в реальном времени. Поэтому, так как для построения достаточно детального изображения не требуется рассчёт отражений и бликов, используется простая диффузная закраска с использованием закона Ламберта.

\section{Вывод}
В данном разделе была рассмотрена трёхмерная виртуальная среда. Рассмотрены объекты, содержащиеся в виртуальной среде, включающие в себя виртуальную сцену, являющуюся контейнером для остальных объектов, аватар робота Ф-2, являющийся эмуляцией реального прототипа робота Ф-2 и аватар пользователя, являющийся источником данных для виртуального аватара робота Ф-2. Описаны данные, которыми обмениваются аватар робота Ф-2 и аватары пользователя в процессе проведения экспериментов, включающие в себя положение лица пользователя и фразы на натуральном языке. Проанализированы алгоритмы и методы, использующиеся при реализации трёхмерной виртуальной среды, в результате для представления примитивов был выбран список трёхмерных полигонов, в качестве алгоритма удаления невидимых линий и поверхностей выбран алгоритм, использующий Z-буфер, в качестве алгоритма закраски был выбран алгоритм основанный на законе косинусов Ламберта.

\begin{comment}
\chapter{Конструкторский раздел}

2.1 Общий алгоритм решения задачи
     1. Задать объекты сцены
     2. Задать камеру (наблюдателя)
     3. Задать источники света
     4. Если был выбран режим просмотра, то выполнить пункты 4.1 — 4.2
         4.1. Используя алгоритм z-буфера получить изображение сцены
         4.2. Отобразить изображение
     5. Если был выбран режим создания качественного изображения, то выполнить пункты 5.1 — 5.3
         5.1. Используя алгоритм трассировки лучей получить изображение сцены
         5.2. Отобразить изображение сцены
         5.3. Запросить подтверждение пользователя на сохранение изображения в файловой системе компьютера
     6. Если был выбран режим создания модели из изображения, то выполнить пункты 6.1 - 
         6.1. Запросить у пользователя путь до папки, в которой находится файл, содержащий изображение
         6.2. Считать изображение из файла в объект, предназначенный для хранения изображения
         6.3. Подготовить полученные данные для анализа алгоритмами машинного обучения
         6.4. С помощью алгоритма получения модели сформировать новый трёхмерный объект
         6.5. Перейти в режим просмотра, и отобразить полученный из изображения объект на сцене

\section{Алгоритм закраски}

Простой алгоритм закраски треугольного полигона реализуется при помощи использования результатов векторного произведения. Для определения того, находится ли точка внутри треугольника вычисляются три векторных произведения для каждого ребра. Каждое векторное произведение рассматривает векторы, начало которых лежит в точках, образующих ребро, а конец в проверяемой точке. Пусть вектор из начальной точки будет a, а из конечной b, тогда по знаку результата выражения a_x * b_y – a_y * b_x мы сможем узнать, с какой стороны от вектора, образуемого из начальной и конечной вершин ребра, находится точка. Если меньше нуля, то справа, если больше, то слева. Алгоритм выглядит следующим образом:

Входные данные алгоритма — координаты точек входа x_1, y_1, x_2, y_2, x_3, y_3; цвет закраски — color.
     1. Определяются координаты x_max, y_max, x_min, y_min ограничивающего треугольник прямоугольника.
     2. В цикле от y = y_min до y_max с шагом 1 выполнять:
         2.1. В цикле от x = x_min до x_max с шагом 1 выполнять:
             a) Определяем положение точки относительно ребра x_1, y_1
             b) Определяем положение точки относительно ребра x_2, y_2
             c) Определяем положение точки относительно ребра x_3, y_3
             d) Если точка находится слева относительно всех рёбер, то закрашиваем пиксель с координатами (x, y)
             e) Иначе идём дальше по циклу

\section{Алгоритм z-буфера}

Входные данные алгоритма — цвет закраски изображения color.

     1. Присвоить всем элементам кадра одинаковое фоновое значением
     2. Инициализировать z-буфер минимальным значением глубины
     3. Выполнить растровую развёртку каждого треугольного полигона сцены:
         3.1. Для каждого пикселя растрируемого полигона вычислить глубину z(x, y)
         3.2. Сравнить глубину пикселя со значением, хранящимся в z-буфере. Если z(x, y) > zбуф(x, y), то zбуф(x, y) = z(x, y), цвет пикселя (x, y) = color.
     4. Отобразить результат

\section{Простой метод освещения}

Простой метод освещения поверхности использует для расчёта интенсивности закон Ламберта, который выглядит следующим образом:

I = I0 · cos(ɑ), где 

I – результирующая интенсивность света.
I0 — интенсивность источника.
ɑ — угол между нормалью к поверхности и вектором направления света.

\section{Алгоритм трассировки лучей}

     1  В цикле от y = 0, y < высота экрана, с шагом один выполнять:
         1.1  В цикле от x = 0, x < ширина экрана, с шагом один выполнять:
             1.1.1  Рассчитать параметры луча, испускаемого камерой для пикселя с координатами x, y. 
             1.1.2  В цикле по всем полигонам сцены определить ближайший пересекаемый полигона
             1.1.3  Если пересечения нет, то пиксель закрашивается цветом фона и цикл переходит на следующий шаг
             1.1.4  Иначе запомнить координаты x’, y’, z’ пересечения
             1.1.5  Из точки пересечения пустить в сторону источника света луч
             1.1.6  В цикле по всем полигонам сцены проверить пересечение луча с полигоном
             1.1.7  Если есть — пиксель с координатами x, y закрашивается цветом фона
             1.1.8  Иначе пиксель закрашивается цветом с учётом интенсивности источника
     2  Отобразить изображение

\section{Алгоритм формирования трёхмерной модели на основе её изображения}
	
Входные параметры алгоритма:
Порог вероятности для первой нейросети — p_1.
Порог вероятности для второй нейросети — p_2.

     1  Запросить у пользователя изображение для обработки
     2  Если изображение успешно загружено — выполнение алгоритма продолжается, иначе — алгоритм заканчивает работу
     3  Приведение изображения к виду матрицы размера (w, h, 3), где w – ширина изображения, h – высота изображения, 3 — количество параметров цвета пикселя в схеме RGB
     4  В цикле от y = 0 пока y < h с шагом 1 выполнять:
         4.1  В цикле от x = 0 пока x < w с шагом 1 выполнять:
             4.1.1  Вычисление первой моделью машинного обучения координаты z для x и y и вероятности того, что эта точка действительно существует в этих координатах.
             4.1.2  Если полученная вероятность больше чем p_1, то точка записывается в массив вершин
             4.1.3  Иначе переход на следующий шаг
     5  В цикле от y = 0 пока y < h с шагом 1 выполнять:
         5.1  В цикле от x = 0 пока x < w с шагом 1 выполнять:
             5.1.1  Вычисление второй моделью машинного обучения вероятности того, что между двумя точками существует ребро
             5.1.2  Если полученное значение больше чем p_2, то ребро записывается в массив вершин.
     6  В цикле для r_1 = ребро из массива рёбер выполнять:
         6.1  В цикле для r_2 = ребро из массива рёбер выполнять:
             6.1.1  Если r_1 != r_2 (хотя бы одна пара вершин не совпадает)
                 6.1.1.1  Если хотя бы одна пара вершин совпадает, то:
                     6.1.1.1.1  Сформировать треугольный полигон из вершин рёбер r_1 и r_2 и добавить его в массив треугольных полигонов
     7  Если массив треугольных полигонов не пуст:
         7.1  Перейти в режим просмотра объектов
         7.2  Поместить сформированный объект на сцену
         7.3  Сформировать изображение сцены
     8  Конец алгоритма

\section{Выбор используемых типов и структур данных}

Источник света — задаётся позицией в пространстве сцены, направленностью света, функцией затухания в зависимости от расстояния (линейная, квадратичная, отсутствует).

Объект сцены — задаётся как список треугольных полигонов.

Камера — задаётся позицией в пространстве сцены, направлением взгляда.

Математические абстракции:
	Точка — хранит координаты x, y, z.
	Вектор — хранит направление по x, y, z.
	Треугольник — хранит три точки, составляющие треугольный полигон
	Матрица 4х4 — хранит матрицу размером 4 на 4
\end{comment}