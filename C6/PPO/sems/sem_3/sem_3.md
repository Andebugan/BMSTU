# Семинар 3. SOLID
Нет смысла использовать SOLID ради SOLID и паттерны ради паттернов.

- SRP - single responcability princip - две формулировки:
    - Существует лишь одна причина, приводящая к изменению класса. 
    - Модуль представляет из себя законченную сущность.
``` 
DBContext
{
    public DBSet<Customer> Customers - некое множество/коллекция/таблица
    ...
    DBSet <Order> Orders
}
С одной стороны удволетворяет SRP - DBContext предоставляет доступ к объектам базы, с другой стороны это мусорный класс.

Active Record - паттерн, позволяющий создавать объекты базы данных, которые могут сохраняться, загружаться и работать с сами собой.
```
Проблема SRP состоит в том, что всё зависит от того, с какой точки зрения мы смотрим за вопрос.

Суть - стараться писать код так, чтобы изменения в конкретном месте имели максимально локальное воздействие.

Пример из паттерна MVC
```
SomeMethod() - метод контроллера
{
    ...
    data = DBContext.Orders.Query("Select * from ...");
    processData(data);
    dataToXML(data);
}
Сущность зависит от входных параметров, обработки данных и формата конвертации. Три причины изменения сущности. 

В качестве решения проблемы - заменить dataToXML на абстрактный интерфейс, делегировать работу с базой данных другой сущности.
```
Если видно, что сущность меняется из-за нескольких причин, то возможным решением может быть дробление класса на несколько классов, которые соответствуют SRP.

- OCP - open-closed principe - принцип открытости-закрытости. Сущность должна быть открыта для изменения но закрыта для модификации. Старую функциональность менять нельзя, но можно добавить новые методы.

```
GetDeliveredOrders()
{
    DBContext.Orders.Where(o=>o.IsDelivered);
    ...
    return query.tolist();
}
```
Если вариантов сортировки много, то может получиться множество методов для каждого из вариантов. Возможное решение:
```
IFilter
{
    Apply(DBSet orders);
}

GetDeliveredOrders(IFilter[] filters)
{
    for filter in filters:
        DBContext.Orders.Where(o=>o.filter);
    ...
    return query.tolist();
}
```
- LSP - liskov substitution principle - принцип подстановки Барбары Лисков. Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
- ISP - interface substitution principle - принцип разделение интерфейсов. Общий посыл - делайте интерфейсы маленькими. Нельзя в интерфейсе реализовывать то, чем разработчик при разработке не планирует пользоваться. При разделении стоит руководствоваться принципом SRP.
- DIP - dependency inversion principle - принцип инверсии зависимости - проектирование ведётся от абстракции, а не от практической реализации.