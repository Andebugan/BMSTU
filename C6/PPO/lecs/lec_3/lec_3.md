# ППО. Лекция 3.
# Проектирование программных компонентов

Прошлая лекция - организация программных компонентов, принципы SOLID. 

Уровни проектирования:
- уровень функций и методов
- уровень классов
- уровень организации компонентов
- архитектурный уровень

Компонент - единица развёртывания. Т.е. некоторая абстракция, с помощью которого мы декомпозируем программное решение на некоторое количество независимых единиц развёртывания. 

Можно независимо обновлять и запускать программные компоненты. Возможные расширения программных компонент - dll, gem, jar, npm, exe.

## История компонент
- Неперемещаемые библиотеки - программа обращается к некой статичной библиотеке. Невозможно перенести программу.
- Перемещаемые библиотеки - добавляется загрузчик, перемещает библиотеки в нужное место.
- Компоновщик (редактор звязей) - позволяет собирать программы с учётом библиотек, применяется в C/C++.
- Динамические библиотеки - динамически подгружает библиотеку по ходу работы программы.

## Компоненты
Программные компоненты - динамически связаываемые фйлы, которые можно подключать во время выполнения (связывающий загрузчик).

Программные компоненты - единицы развёртывания. Программные компоненты образуют граф зависимости, охватывающий всю программу. Данный граф является одной из главных характеристик программы.

## Принципы связности компонентов
- REP: Reuse/Release Equivalence Principle - принцип эквивалентности повторного использования и выпусков.
- CCP Common Closure Principle - принцип согласованного изменения.
- CRP: Common Reuse Principle - принцип согласованного использования.

### REP
Выпуск - номер версии, описание новой версии, change log. Номер версии формируется как мажорная_версия.минорная_версия.внутренний_счётчик. Change log - added, deleted, modified.

Единица повторного использование - единица выпуска. Классы и модули, объединяемы в компонент должны выпускаться вместе. Объединение в один выпуск должно иметь смысл для автора и пользователей.

Если при обновлении библиотеки не изменяются использующиеся функции, то возможно библиотека объединяет слишком много функций. При разработке необходимо думать о том, насколько изменения касаются конечных пользователей, если изменяются и добавляются слишком разные классы, то стоит разделить библиотеку на несколько небольших библиотек.

### CCP
Развился из SOLID. 
- В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время.
- В разные компоненты должны включаться классы, изменяющиеся по разным причинам и в разное время.

Данный принцип, как и предыдущий, указывает на необходимость централицации компонента.

Для польшинства приложений простота сопровождения важнее возможности повторного использования.

Имеется ввиду, что обычно разработка подразумевает повторное использование посредством выделения общих частей, что позволяет снизить количество ошибок, возникающих при модификации. Однако CCP говорит обратно, поскольку вынося в общее алгоритмы, похожие друг на друга, однако имеющие разные причины для изменения, возникнет необходимость разделить общий модуль.

Идея прицнипа - объединение в компонент классов, закрытыз для одного и того же вида изменений. 

Это приводит к тому, что при изменение требований приведёт к изменению минимального количества компонентов.

### CRP
Классы, не имеющие общие связи не должны включаться в компонент.

Данный принцип является развитием принципа разделения интерфейсов из SOLID.

- Не вынуждайте пользователей компонента зависеть от того, что им не требуется
- Классы, не имеющие тесной связи не должны включаться в компонент

Не создавайте зависимостей от чего-то неиспользуемого.

## Баланс
Баланс - главная задача архитектора.

<-> REP <-> много ненужных выпусков <-> CPP <-> проблемы с повторным использованием <-> CRP <-> изменения затрагивают много компонентов <->

## Связь компонентов между собой
Основная связь - отношение зависимости. 

Принципы сочитаемости компонентов:
- принцип ацикличности зависимостей
- принцип устойчивых зависимостей
- принцип устойчивости абстракций

### Принцип ацикличности зависимостей (ADP)

Циклы в графе зависимостей недопустимы. Отдельные компоненты - отдельные разработчики/команды. Появление цикла - появление одного большого компонента. Граф зависимостей - ациклический ориентированный граф.

Разрыв цикла:
- применение инверсии зависимостей
- новый компонент, от которого зависят проблемные компоненты

## Проектирование сверху вниз
- Граф зависимости формируется для защиты стабильных и ценных компонентов от влияния изменчивых компонентов.
- Структура компонентов отражает удобство сборки сопровождения и слабо отражает функции приложения. 

### Принцип устойчивых зависимостей

Зависимости должны быть направлены в сторону устойчивости.

Устойчивость - способность сохранять своё состояние при внешних воздействиях. 

Метрика неусточивости = выходы / (входы + выходы). I = 0 - максимальная устойчивость, I = 1 - максимальная неустойчивость. 

SDP - метрика неустойчивости компонента должна быть выше метрик неустойчивости компонентов, от которых он зависит.

Однако стоит учитывать, что не смотря на то, что зависимости легко управляются разработчиками, в общем случае метрика указывает на общую устойчивость системы. Если ближе к 1, то неустойчив, ближе к 0 - устойчив.

### Принцип устойчивости абстракций

Устойчивость компонента пропорциональна его абстрактности.

Абстрактность (A) = число абстрактных классов и интерфейсов / число классов.

Пример - компоненты, содержащие только интерфейсы в C# и Java.

